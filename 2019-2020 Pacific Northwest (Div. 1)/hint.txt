https://codeforces.com/gym/102433
A: 这道题可以想到需要O(1)来移动点，比较重要的是用公式来formalize要求的值。另一个比较重要的点是想到构造成树，因为可以察觉到是u的一侧会增加w，一侧会减少w，但是不太直观。假如变成树就容易想多了，遍历顺序也更加容易想。假设从u->u'，则以u'为root的subtree距离都会-w，而别的都会+w
B: 可以用单调栈来解，并且要记录下每个元素最后出现的位置。有几种情况：1. a[i]>b，则直接将a[i]给push进去，因为{b, a[i]}是一个合理的序列。2. 比较当前的a[i]和堆顶的元素b，假如a[i]<b并且b在之后还会出现，那么说明可以达到{a[i], ..., b}的顺序，肯定是比{b, ..., a[i]}小的，所以就可以将b给pop掉。以此类推将堆顶的元素都pop掉，然后再将a[i]给push进去。3. 其实应该优先考虑a[i]是否已经在序列里了，假如已经存在那就是当前最好的。假如不是，那说明在a[i']与a[i]中间有更小的值b，但是以我们之前的做法，在遍历到b的时候会将a[i']给pop掉，所以已经在stack里面的a[i]是当前最优
C: 对于相邻边交错染色，假如一点到source的最近距离是d，那么可以保证有d-1次change。因为假如bob走最短路，那我们就将其交错染色；假如不走最短路，从中间叉出去再回来，那么这条路p'一定是比最短路中那一部分p长的，所以我们也可以通过交错染色使p'>=p
G: 首先考虑对于一个horizontal的current，有哪些vertical的current可以与它相遇。假设这两个current分别是{time_h, row, len_h}和{time_v, col, len_v}。可以知道他们会在(row, col)相遇，所以horizontal会在那点的时间是[time_h+col, time_h+col+len_h]，而verticla会在那点的时间是[time_v+row, time_v+row+len_v]。为了让区间只包含自己的信息，将两边同时减去row+col，可得[time_h-row, time_h-row+len_h]和[time_v-col, time_v-col+len_v]。假如这两个区间有交集，则那个点就是亮的。该题中另外一个条件是，每条横轴或纵轴只会出现一次，因此只要考虑有多少个vertical和horizontal区间的交集就行了，是不会重复的。因此又用到event processing来计算交集个数，对于start计算另一个方向还没end的区间，其实这种做法也是sweep line的变种：
  v---v v---v
h--------h h---h
同样要注意的是把start写为1，end写为-1，这样出现如下重叠的情况会先处理end，不会被记为交集：
v-v
  h---h
I: 将能转换的点相连，则是要找maximum independent set，意思就是任意两点之间不相连。但是在图上找是NP-hard。根据群论的知识，可以发现所有的组合拥有permutation parity的特性，可以通过数string中有多少逆序对，来将所有点分成奇偶两组。然后剩下的就是在bipartite中找最大独立集。根据“最大独立集+最大匹配=点数”的性质，我们只需要找到最大匹配就可，用maximum flow
J: 可以这样考虑这道题，在xy平面上，有很多个正的等腰三角形相加，我们需要在[0, 2*PI)的范围内找到最高点。首先一个重要的结论是最高点必定是某个等腰三角形的顶峰，其原因是对可导处每点求导都是constant。首先假设等腰三角形在y=0处会继续向下延伸，并且最高点不在顶峰，而在两个顶峰之间。此时这两个顶峰之间的斜率是多个斜率的线性叠加，所以必然是{正constant, 0, 负constant}中的一个：假如是0，那也就可以延伸到其中一个顶峰；否则必定可以向上升的一方延伸到其中一个顶峰。现在考虑等腰三角形在min()=0的情况，可知会有一段的斜率更加大：对下降的斜线而言，可能会出现低谷；对于上升的斜线而言，总体而言仍然是上升的。因此不可能出现高峰，所以对于最高点而言，总能找到一个方向是上升的，从而移动到那个顶峰。接下来对于每个顶点，假如暴力做的话需要O(n^2)，因此可以将三角形排序后用sweep line来做，记录两个底角和一个顶角的位置，然后记录下斜率变化。但是这个需要注意的是，假如斜率特别小，则可能达不到y=0，但是由于是circular的，所以在a-PI处是低谷，然后又会上升，因此可以将其最低点作为基底加到cur，然后把它向下平移到a-PI处为0。同样要注意的是s=0的情况，完全是一条直线：
 0       2*PI
 |        |
 |--------|
 |        |
----------------
我们实际在意的是[0, 2*PI)范围内的，但是有些三角形的底角会<0，因为我们是从0开始累加的，所以得要从最左点开始。有些底角是>2*PI，要描绘出<2*PI处被切掉的那一段：
 0       2*PI
 |/\      |/\
 |  \     |  \
 |   \   /|   \
----------------
 0       2*PI
 |       /|
 |\     / |\
 | \   /  | \
----------------
可以看到有多种情况，所以最佳的做法是加上一个完整的三角形，这样可以包含如下的情况。在>2*PI的区域是重复的，但是多余部分的结果只可能更小不可能更大：
 0   /\  2*PI /\
 |\ /  \  |\ /  \
/| /    \/| \    \
 |/ \   /\|/ \    \
--------------------
L: 设a的长度为n，则a*a的长度是2*n+1。从最高位开始，每位从0~9遍历，则第一个出现的结果就是最小符合的值。第i位由a[i]*a[0]+a[i-1]*a[1]+...+a[0]*a[i]组成，遍历完前n位后已经得出a，对后n-1位进行检验
M: 将迷宫中相连的部分和外部整体视为一个点，这样就是要加边使得所有components相连，那就是点数-1。因此剩下的是如何将原图转化为点，可以将横纵坐标扩大一倍，然后将每个\和/转化为两个#，转换的结果类似：
. . . . . . . . . . 
. . # # . . . . . . 
. # . . # . . . . . 
. # . . . # . . . . 
. . # . . . # . . . 
. . . # . . # # . . 
. . . . # # . . # . 
. . . . . # . . # . 
. . . . . . # # . . 
. . . . . . . . . . 