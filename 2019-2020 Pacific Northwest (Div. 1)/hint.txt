https://codeforces.com/gym/102433
A: 这道题可以想到需要O(1)来移动点，比较重要的是用公式来formalize要求的值。另一个比较重要的点是想到构造成树，因为可以察觉到是u的一侧会增加w，一侧会减少w，但是不太直观。假如变成树就容易想多了，遍历顺序也更加容易想。假设从u->u'，则以u'为root的subtree距离都会-w，而别的都会+w
B: 可以用单调栈来解，并且要记录下每个元素最后出现的位置。有几种情况：1. a[i]>b，则直接将a[i]给push进去，因为{b, a[i]}是一个合理的序列。2. 比较当前的a[i]和堆顶的元素b，假如a[i]<b并且b在之后还会出现，那么说明可以达到{a[i], ..., b}的顺序，肯定是比{b, ..., a[i]}小的，所以就可以将b给pop掉。以此类推将堆顶的元素都pop掉，然后再将a[i]给push进去。3. 其实应该优先考虑a[i]是否已经在序列里了，假如已经存在那就是当前最好的。假如不是，那说明在a[i']与a[i]中间有更小的值b，但是以我们之前的做法，在遍历到b的时候会将a[i']给pop掉，所以已经在stack里面的a[i]是当前最优
C: 对于相邻边交错染色，假如一点到source的最近距离是d，那么可以保证有d-1次change。因为假如bob走最短路，那我们就将其交错染色；假如不走最短路，从中间叉出去再回来，那么这条路p'一定是比最短路中那一部分p长的，所以我们也可以通过交错染色使p'>=p
F: 这是一道dp题，难点在于想到还需要一维数据x来记录剩余位置中有x个可以match的点。g(n, m, x)中的x指的是后n个位置中有x个可以match的点，也就是说剩下可用的数有x个在[pos ~ pos+n-1]中。对于g(n, m, x)，固定x中的m个点，则是一种combination，变成g(n-m, 0, x-m)。然后可以发现g(n, 0, 0)=n!，g(0, 0, 0)=1。对于g(n, 0, x)的一般转化方程，假如x是{a, b, ...}，然后a占用了b的位置，那x的个数就会-2；假如a占用了除x之外的位置，那x个数-1。到此为止我们可以得到所有的g(n, m, x)。注意在计算过程中可以用combination的递推表达式来计算，但是它和阶乘都会超过ll的限制，而k是在ll限制之内的，所以假如超过了ll，就以一个比k大的数来代替就行。接下来要生成最后的结果，对每一位pos从小到大尝试所有的数，并且计算[pos+1 ~ n]中的情况cnt，然后从k减去，假如cnt>k，说明这一位是对的，因此可以跳到下一位。要注意的是得要更新x的值，对于每个pos，最开始x代表的是[pos ~ n]中能用的个数，接下来我们计算g需要用到[pos+1 ~ n]中能用的个数。假如这一位的值还没被用：那么在假如用在自己这一位，那就-1；假如用在之后的某一位，也就是dig>pos，那就额外需要-1。假如这一位已经被用了，那x代表的就是[pos+1 ~ n]中可用的范围，所以不用在最开始-1，但是仍然要考虑dig>pos的情况
G: 首先考虑对于一个horizontal的current，有哪些vertical的current可以与它相遇。假设这两个current分别是{time_h, row, len_h}和{time_v, col, len_v}。可以知道他们会在(row, col)相遇，所以horizontal会在那点的时间是[time_h+col, time_h+col+len_h]，而verticla会在那点的时间是[time_v+row, time_v+row+len_v]。为了让区间只包含自己的信息，将两边同时减去row+col，可得[time_h-row, time_h-row+len_h]和[time_v-col, time_v-col+len_v]。假如这两个区间有交集，则那个点就是亮的。该题中另外一个条件是，每条横轴或纵轴只会出现一次，因此只要考虑有多少个vertical和horizontal区间的交集就行了，是不会重复的。因此又用到event processing来计算交集个数，对于start计算另一个方向还没end的区间，其实这种做法也是sweep line的变种：
  v---v v---v
h--------h h---h
同样要注意的是把start写为1，end写为-1，这样出现如下重叠的情况会先处理end，不会被记为交集：
v-v
  h---h
H: 这里要注意是line，所以两端都是无限延长的，但是因为要转360度，所以可以假设他是有方向的。对于每个pivot的点p和下一个pivot的点p'，可以作为一个event，总共有O(n^2)个不同的events。因为转了360度后会回到起始点，所以相当于经过了一系列events后回到了开始，就像一个环。并且从环上任意一点开始，它也会完全遵循这条路径，然后回到这一点。可以发现所有的events可以分成多个disjoint cycle，只要从任意一点开始就能遍历这整个环上开始的情况。可以发现最多有O(n)个环，对于每个点作为pivot找一个相同的方向使其不与任何点相交，也就说明了最多有O(n)个环。假如有更多的环，因为要转360度所以他一定会到那个方向，那他一定会在那个方向上属于以上其中一种状态，那就属于那个环了。因此接下来就是模拟，对于event找下一个event，遍历别的所有点需要O(n)，总共就需要O(n^3)。但是我们可以对每一点预处理，将别的点sort之后求出每个event的下一个event与转的角度，这样就是O(n^2logn)。要注意的是因为是line所以在考虑下一event的时候要计算直线两侧的点，并且用后一个减前一个时，要注意[3, 0.1]=0.1-3变成负数的情况，需要+PI。另外需要注意最后一开始是从j到i，然后i会作为pivot找k，然后k作为pivot
I: 将能转换的点相连，则是要找maximum independent set，意思就是任意两点之间不相连。但是在图上找是NP-hard。根据群论的知识，可以发现所有的组合拥有permutation parity的特性，可以通过数string中有多少逆序对，来将所有点分成奇偶两组。然后剩下的就是在bipartite中找最大独立集。根据“最大独立集+最大匹配=点数”的性质，我们只需要找到最大匹配就可，用maximum flow
J: 可以这样考虑这道题，在xy平面上，有很多个正的等腰三角形相加，我们需要在[0, 2*PI)的范围内找到最高点。首先一个重要的结论是最高点必定是某个等腰三角形的顶峰，其原因是对可导处每点求导都是constant。首先假设等腰三角形在y=0处会继续向下延伸，并且最高点不在顶峰，而在两个顶峰之间。此时这两个顶峰之间的斜率是多个斜率的线性叠加，所以必然是{正constant, 0, 负constant}中的一个：假如是0，那也就可以延伸到其中一个顶峰；否则必定可以向上升的一方延伸到其中一个顶峰。现在考虑等腰三角形在min()=0的情况，可知会有一段的斜率更加大：对下降的斜线而言，可能会出现低谷；对于上升的斜线而言，总体而言仍然是上升的。因此不可能出现高峰，所以对于最高点而言，总能找到一个方向是上升的，从而移动到那个顶峰。接下来对于每个顶点，假如暴力做的话需要O(n^2)，因此可以将三角形排序后用sweep line来做，记录两个底角和一个顶角的位置，然后记录下斜率变化。但是这个需要注意的是，假如斜率特别小，则可能达不到y=0，但是由于是circular的，所以在a-PI处是低谷，然后又会上升，因此可以将其最低点作为基底加到cur，然后把它向下平移到a-PI处为0。同样要注意的是s=0的情况，完全是一条直线：
 0       2*PI
 |        |
 |--------|
 |        |
----------------
我们实际在意的是[0, 2*PI)范围内的，但是有些三角形的底角会<0，因为我们是从0开始累加的，所以得要从最左点开始。有些底角是>2*PI，要描绘出<2*PI处被切掉的那一段：
 0       2*PI
 |/\      |/\
 |  \     |  \
 |   \   /|   \
----------------
 0       2*PI
 |       /|
 |\     / |\
 | \   /  | \
----------------
可以看到有多种情况，所以最佳的做法是加上一个完整的三角形，这样可以包含如下的情况。在>2*PI的区域是重复的，但是多余部分的结果只可能更小不可能更大：
 0   /\  2*PI /\
 |\ /  \  |\ /  \
/| /    \/| \    \
 |/ \   /\|/ \    \
--------------------
K: 假如只有1和2操作，那就对load data用segment tree的lazy propagation，每一点记录data的index，开始的位置和结束的位置，然后在update或是query的时候push。因为只是单点查询，所以最后assign会被push到叶节点。但因为要考虑操作3，所以需要用persistent segment tree来记录历史的increment。这样在cache的segment tree里再记录下是第几个version。然后对于那个叶节点，到data里面找到那个版本，然后找到那个地方的数据。对于data的persistent segment tree，也需要使用lazy propagation，这里就是range addition和query单个元素，所以把初始value存在叶节点，然后inc存在segment里，从下往上累加所有的inc。在lazy propagation persistent时对于不用改动的child，可以不用new，直接返回原来的那个info。在update persistent时，新的info需要使用原来info里的inc。需要使用memory efficient的segment tree，因为总共2*n-1个node，不需要写成4*n个，左child为v+1，左边最多有2*(mid-l+1)-1个，右child为v+2*(mid-l+1)
L: 设a的长度为n，则a*a的长度是2*n+1。从最高位开始，每位从0~9遍历，则第一个出现的结果就是最小符合的值。第i位由a[i]*a[0]+a[i-1]*a[1]+...+a[0]*a[i]组成，遍历完前n位后已经得出a，对后n-1位进行检验
M: 将迷宫中相连的部分和外部整体视为一个点，这样就是要加边使得所有components相连，那就是点数-1。因此剩下的是如何将原图转化为点，可以将横纵坐标扩大一倍，然后将每个\和/转化为两个#，转换的结果类似：
. . . . . . . . . . 
. . # # . . . . . . 
. # . . # . . . . . 
. # . . . # . . . . 
. . # . . . # . . . 
. . . # . . # # . . 
. . . . # # . . # . 
. . . . . # . . # . 
. . . . . . # # . . 
. . . . . . . . . . 