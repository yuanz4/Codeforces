https://naq20.kattis.com/problems
A: 将人物之间连线，然后找SCC
B: 找圆之间的intersection，转化为找圆和线之间的intersection。对于每个新画上去的圆，和之前所有的圆进行比较，然后将旧的圆的一部分截去，然后对新圆将(-PI, PI]加上。对一个旧圆的截取可能是重复的，因此我们先将这些删去的范围全部记起来(在(-PI, PI]范围内)，然后在最后对每个圆找出范围的总和，sort一下之后处理。因此总的时间复杂度为O(n^2*logn)。要注意考虑两个圆相对位置时有很多情况：0或1个交点时要考虑是谁包含谁或是不包含，2个交点时要根据两圆的位置来判断是哪一段弧被消去了（用一个旧圆圆心指向新圆圆心的vector来找到旧圆上的那个交点，交点应该是在弧的范围内，它与另外两个交点的弧都在PI以内；或者可以在旧圆上任意取一点，然后检测那一点是否在新圆内部）。将旧的圆放到origin会方便一点，要注意输出的小数点精度
E_tree: 将其build成tree，将对于每个点的child，将他们减去parent length（意思是有一部分可以向parent延伸），剩下的数字之间进行配对成为两组，要注意这里不是严格的将所有数字分为两组，比如[3, 4, 5]，可以组合成3+3和1+5。因此我们只在意最大的那个数字和剩下的数字之和，假如mx比剩下的大，则最后会有sum-mx个pair和2*mx-sum个独立的，因此总共mx。否则的话一定能将其分均分为两组。要考虑减去parent length，只需要对mx减去parent length来检测是否比剩下的大，假如不是的话那也一定能均分为两组
E_graph: 其实并不需要tree，最开始每条边单独算作一份，ans=total，对于每个点来说要把所有相邻的边进行pair，因为对于每个点来说进边都是独立的，然后ans-=paired_edges
G: 假如不考虑k，那么对于一片低洼地带，可以发现最终结果会收敛到两处的高峰，最终会变成一个凸包。比如[4, 1, 3, 7, 4]最终会变成[4, 5, 6, 7, 4]。假设input是A，然后B满足B[i]=(B[i-1]+B[i+1])/2+K，而C[i]=A[i]-B[i]，则A[i]=max(A[i],(A[i-1]+A[i+1])/2+K)等效于C[i]=max(C[i],(C[i-1]+C[i+1])/2)。然后我们用convex hull来计算C（这里比较两端线段的斜率），最终再加上B，取其中最大的那个
H: 如果不仅仅可以往上或者往右走，也可以往下或者往左走，那就要将其变成一张图，总共有l层，l为key code的长度。然后我们build graph，如果要使用key code就要在图层间移动，否则是图层内。这题里不会出现negative cycle，所以可以用shortest path。从第一层的左下角出发，最终要计算所有l层中到右上角最短的路线