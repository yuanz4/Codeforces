https://codeforces.com/contest/1471
B: 每当一个数可以被divide，会在最后加上总和为a[i]的值。列出每个数能被除几次，比如x=2，16(4), 6(1), 8(3), 4(2)，5(1)。先遍历前n个数，然后在第一层时每个数都ok，但是到第二层时6会被卡住，之后的数都不行了。因此我们需要从后往前找最小值，有一样的取较前面的。假设该最小层数为l，则在该元素之前的数都能被加l+1次，该元素及之后只能被加l次。另一种做法是模拟，可以每次在vector最后加上{cur/x, a[i]}，然后把sum加上a[i]。这样做不会超时是因为每个数最多被加O(logA)次，所以时间复杂度是一样的，都是O(n*logA)
C: 假如都给钱，肯定是最贵的。可以将k排序，较小的给钱，较大的买礼物。对k倒序排序，然后给最大的k从第一个礼物开始给，比较是给钱还是给礼物好。假设A, B两人有KA<=KB，并且他们收到a<=b的礼物。此时有a<=C_KA?b<=C_KB。那假如把a给B，然后A取min(b, C_KA)，这样会相等或更小。更加直观的想法是，将C和K想成两个上升的三角形，将两者重叠，对每点求较小值。此时反着叠会更小：
  .....   ...         .
 ...... + ....    =  ...
.......   .......   .......
D: 首先可知是perfect square时x*y为perfect square。假如a*b满足，b*c满足，则a*c也满足，因此可以将他们归到一个group。同一个group在一次操作之后会等于一样的值，这个值可能是square也可能不是。对于那些是square的值，他们相乘一定也是，所以可以合并。可以猜测到对于那些不是square的group，彼此之间不可能合并，因此只需要考虑w=0,1的情况。在划分group的时候假如两两相乘的话就要O(n^2)，可以将exponents%2，比如540=2^2∗3^3∗5=3∗5。这样所有的square都会变成1，而同一个group中的数都拥有相同的分解。因此当group的size为偶数时，会变成1。而为奇数时，product就是分解本身，同时也证明了不同group直接不可能合并，因为合并的条件是分解完全相同。如果用最基础的质因数分解，是O(n*sqrt(A))，有更快的做法，用到sieve和smallest prime factor来达到O(n*logA)
E: 模拟过程，可以发现一些规律。impostor的值会保持k不变，从p+1到p-1
会是从大到小。当n是偶数时，除了p之外，最终有l=n/2-1个比k大，1个为k，l个比k小。当n是奇数时，除了p之外，最终有l=(n-1)/2个比k大，l个比k小。并且前l步，比k大和比k小的数都会+1。但是在l步之后，这两块内部还会浮动，最后稳定所需要的步数是不确定的，也可能会一直振荡。现在我们需要找到这样一个<k的值，然后往右搜索，但是这个<k的sequence本身也是在往右延伸的，所以什么时候能找到是个问题。很显然我们不能等l步，那样的话query过多。这时候需要用到sqrt decomposition，前sqrt(n)步会产生两个长度为sqrt(n)的>k和<k的block，所以我们先等sqrt(n)步，然后再将总长分为sqrt(n)长度的block，对每个block检测头部元素，这样总能找到一个<k的元素。然后对右边长度为l+1的区域内做binary search，找值为k的。但是要注意的是，可能会搜索到>k block中还未变为k的位置，比如以下例子中最右边的20：
5 3 |20| 37 35 33 20 20
这时候需要找到所有等于k中最左边的那个，可以保证是p。这样总时间复杂度是O(2*sqrt(n)+logn)，对于这种interactive的题目可以用宏来自己模拟input。在editorial中用数学归纳法证明了距离p相等距离的两点和为2k，因此也可知p一直保持k（可以分类讨论p左右为奇数和偶数的情况），并证明了[p+1,p+2,...,n,1,...,p-1]单调不增。最后证明了前l步，比k大和比k小的数都会+1
F: 可以想到是用染色的方法，令黑色为住人，白色为不住人。因为没有要求最大化黑色，所以可以尝试从任意点开始。这题比较tricky的地方就是，这不是一般的bfs和dfs，比较难想到的是涂色的方法。黑色周围一定都要是白色的，但是白色可以和白色相连。最开始取任意一点涂黑，然后周围都变成白色。然后任意取一点白色周围没着色的，涂为黑色。这样可以保证没有黑色相邻，因为黑色周围都被涂成白色了。而且可以保证每一点都连通，因为选取的黑色一定与白色相连，而白色也是被某一点黑色涂白的