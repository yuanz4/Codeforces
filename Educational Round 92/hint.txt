https://codeforces.com/contest/1389
B: 首先假如往左的步数t确定了，则最终位置是确定的k-2*t，然后再按来回走的pair算总和。这里非常tricky的地方是要按(right, left)来走，并且当最后一个pair最大时是以往左走结尾，不然会少算最后一个pair。当k=5, t=1时：
walk: ...
lr:   ---
rl:   ----
另外一种更快的做法是先确定最终位置，然后计算往左了几次，这样时间复杂度与z无关
C: 不该思考如何去掉元素，而是要想给定两个字符，如何计算去掉了多少个字符。类似于固定答案去计算过程要花费多少
D: 其实有O(1)的解，但是写起来比较复杂。O(n)的解比较好写，而且不会超时。因此比赛的时候应该写容易写并且不会超时的解
F_bipartite: 首先因为是两种颜色，我们可以将其转化为bipartite的问题，将bad pair连起来。我们的目标是找到若干点，使其中间没有线。这其实是找最大独立集的问题，可以用最小点覆盖与最大匹配证明，其值为点数n减去最大匹配数。但是我们不可能将所有点连起来来求最大匹配，那样是O(n^2)。对于某一个segment，我们要找的是对面segment中最早结束的。
c1: 0000110111
c2: 1110011101
在这个例子中，对于c2中第二个segment，我们要找c1中与其匹配的最早结束的，这样c2中第三个segment才能匹配到，所以可以用event processing approach来解决。这里比较巧妙的是将start和end的时间都sort，当遇到start时将end存进set里。在例子中c2中第一个segment在遇到end时c2仍然是空的，所以不会增加匹配，而是直接erase。用{time, {start/end, i}}来记录，使得每一个pair都是unique的。另一个巧妙的地方在于，当有{time_j, {start, i}}，{time_i, {end, j}}的pair中time相同时，会先处理start的那个，比如例子中c1的第一个和c2的第二个，使end的那个不会被提前删掉