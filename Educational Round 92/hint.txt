https://codeforces.com/contest/1389
B: 首先假如往左的步数t确定了，则最终位置是确定的k-2*t，然后再按来回走的pair算总和。这里非常tricky的地方是要按(right, left)来走，并且当最后一个pair最大时是以往左走结尾，不然会少算最后一个pair。当k=5, t=1时：
walk: ...
lr:   ---
rl:   ----
另外一种更快的做法是先确定最终位置，然后计算往左了几次，这样时间复杂度与z无关
C: 不该思考如何去掉元素，而是要想给定两个字符，如何计算去掉了多少个字符。类似于固定答案去计算过程要花费多少
D: 其实有O(1)的解，但是写起来比较复杂。O(n)的解比较好写，而且不会超时。因此比赛的时候应该写容易写并且不会超时的解
F_bipartite: 首先因为是两种颜色，我们可以将其转化为bipartite的问题，将bad pair连起来。我们的目标是找到若干点，使其中间没有线。这其实是找最大独立集的问题，可以用最小点覆盖与最大匹配证明，其值为点数n减去最大匹配数。但是我们不可能将所有点连起来来求最大匹配，那样是O(n^2)。对于某一个segment，我们要找的是对面segment中最早结束的。
c1: 0000110111
c2: 1110011101
在这个例子中，对于c2中第二个segment，我们要找c1中与其匹配的最早结束的，这样c2中第三个segment才能匹配到，所以可以用event processing approach来解决。这里比较巧妙的是将start和end的时间都sort，当遇到start时将end存进set里。在例子中c2中第一个segment在遇到end时c2仍然是空的，所以不会增加匹配，而是直接erase。用{time, {start/end, i}}来记录，使得每一个pair都是unique的。另一个巧妙的地方在于，当有{time_j, {start, i}}，{time_i, {end, j}}的pair中time相同时，会先处理start的那个，比如例子中c1的第一个和c2的第二个，使end的那个不会被提前删掉
F_segment_tree: 用dp+segment tree。首先对于某种颜色第i个值，只能是从另一种颜色转换过来的，假如是同一种颜色，无论怎么排序都可能出现问题：比如d[0][i]想要从d[0][i-1]转化过来，但是d[0][i-1]可能会与之后和d[0][i]匹配的颜色为1的线段冲突。当按左端点排序时：{0: [1, 10], [4, 5]}, {1, [6, 7]}，对于[6, 7]，找到一个区间右边是比6小的[4, 5]，但是前一个区间10比6大，因此[4, 5]不能从[1, 10]得到。当按右端点排序时：{0: [4, 5], [1, 10]}, {1, [2, 3]}，对于[4, 5]，找到一个区间右边比4小的[2, 3]，然后[1, 10]想从[4, 5]得到，但是会与[2, 3]冲突。因此对于s[0][i]，在所有右端点比它小的s[1][j]中，需要找那个selected最多的，所以我们对右端点排序，即在[1...s[0][i].l-1]区间内找最大的。假如找到的那个值为s[1][j]，要注意在[s[1][j].r+1, s[0][i].r]这个区间内可能会包含颜色为0的同色segments，需要把这些也加上，比如{0: [2, 3], [4, 5]}, {1: [4, 5], [4, 7]}，[4, 7]找到了[2, 3]，但是[4, 5]也比[2, 3]大，我们想加上它。因此我们能做的是，在处理[4, 5]时，对于颜色为0的处于[1, 3]范围内的segments都+1，相当于对于颜色为1的后续segments加上了[4, 5]这一段同色线段。对于s[0][i]我们得到最大值后，需要将该值写到线段树里。在这里我们讨论的都是实际左右边界的大小，而不是坐标，但因为我们是对右边界排序的，所以从1开始的一段范围其实就是index的prefix。因此我们对两种颜色各有一个segment tree，每个leaf代表处理到并包含那个s的最大值。进行范围查询max和范围加法（lazy propagation），并且对单点进行更改。每种颜色的排过序的数组各有一个指向头的pointer，在判断先走哪个的时候，要保证先走的那个不会排在后走的那个之后，比如[3, 5], [4, 6]中哪个先走都行，但是[3, 4], [5, 6]必须[3, 4]先走，因此对于两个segments取左边界或者右边界中较小的都行。将segtree写成struct，并且包含一个0作为初始点，这样每种颜色leaf的数量都要+1