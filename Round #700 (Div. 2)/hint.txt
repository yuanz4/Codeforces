https://codeforces.com/contest/1480
D: 首先预处理，合并相邻相同元素，记录{val, len}，叫这个数组为b。基本思想是greedily地对当前b[i]取较好地情况（需要证明）。当len=1的时候需要考虑分配不同边来保证不会重叠，例如[3, 3, 5, 4, 3, 3]。对于len>=2，是否需要分配到两边，还是让没有被分配到的那组保持前一个数较好？比如[3, 3, 5, 3, 3]，可以分配成[3, 3, 5, 3]和[3]或是[3, 5, 3]和[3, 3]，对于第一组[3, 3]假如不分配，那在下次见到3的时候也会将其覆盖到，所以是一样的，因此尽可能分配到两边。
当我们处理到b[i]的时候，鉴于预处理我们知道b[i-1]!=b[i]。b[i−1]是其中一种颜色的最后一个，所以我们想知道对于另一种颜色有哪些可以取。我们用一个叫alter的set来记录潜在的元素。对于D1我们希望取不同的元素，对于D2我们希望取相同的元素。
在alter中的元素可以被放到与b[i-1]相同或不同的颜色。我们可以重新排序来将任意在alter中的元素放到那个color的结尾。例如：b[i−1]=3，alter=[1,2,4]。我们可以通过reorder来将1变成其中一种颜色的结尾：[...,2,...,4,...,3] and [...,1]。
对于第一个问题：当b[i]的len≥2，那我们会将其分配到两组。当b[i]的len=1，我们需要考虑放到哪一种颜色。我们知道b[i−1]!=b[i]，所以我们想要检测在另一种color中有没有与b[i]不同的元素，所以我们check alter。如果有的话，那代表b[i]可以放到任意一组，对b[i-1]来说它可以与b[i]同色或是不同色，所以我们可以将b[i]放到alter。如果没有，那代表b[i-1]一定是b[i]的前一个元素，所以b[i-1]是fixed。
对于第二个问题，思路类似并且更加简单，我们只需要check b[i]是不是在alter中并且update alter
D1_greedy: 假设两种颜色的结尾是x和y，然后当前的元素是z，假如z和其中一个相等，则就把z放到另外一个。假如和两个都不相等，就用z替换下次出现更近的那个元素，相当于可以作为挡板。在editorial中给出了证明，非常复杂
D2_dp: dp的状态比较难定义，假如用f(i)代表到i为止最短的情况，很明显a[i]是其中一种颜色的结尾，但是我们不知道另一种颜色的结尾是什么。这里我们不能定义另一种颜色的结尾为1<=j<i，因为这里面有一些不是optimal的，根本不会取到。假如定义f(i)为到i为止最短的情况，并且a[i]和a[i-1]在不同颜色，然后我们把a[i+1...m]都放到和a[i]一起。接下来考虑为什么这样定义状态可以包含所有情况：假如已经有一种分配，然后从末尾往前找，总能找到存在a[i]和a[i-1]不在同一种颜色的情况：
1 3 7 8
2 4 5 6
在这里就是6和7，而7之后的元素都放在和7同色。或者说对于每一个a[i]，他可以选择和a[i-1]同色或是不同色，假如是不同色的情况，假设另一种颜色的结尾此时是a[j-1]：
... a[j] a[j+1] ... a[i-1] ?a[i]
... a[j-1] ?a[i]
这样需要遍历所有情况，但是我们希望a[j-1]与a[i]。editorial中给出了证明，我们只需要考虑last[a[i]]
D2_greedy: 类似D1_greedy，Bélády's algorithm，替换下次出现较晚的那个
E: 答案总是yes，因为看到32，所以可以想到会与bitmask有关。可以分成3种情况，一种是L=1, R=2^k；一种是L=1, R!=2^k；另一种是L!=1。最后一种可以由前两种转变而来，只需要在最后加一条就行。第一种可以这样理解，现在已经可以满足k=0,1,2，要求k=3的情况：
1, ([1] + 1), ([1, 2] + 2), ([1, 2, 3, 4] + 4)
所以除了第一个城市到最后一个城市多加一条1，别的分别加2^k。对于第二种情况，比如13，二进制为1101，可以分解为：
([1] + 0), ([1, 2, 3, 4] + 1), ([1, 2, 3, 4, 5, 6, 7, 8] + 5)
可以看到加的数为二进制中在那一位之前的数的和。但是考虑到边长不能为0，即不能+0，比如有一个二进制分解为1100，则会出现([1, 2, 3, 4] + 0)。所以需要对R-1进行分解，然后将第一个和最后一个加一条1，别的地方加边的时候+1