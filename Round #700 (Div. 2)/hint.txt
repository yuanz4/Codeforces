https://codeforces.com/contest/1480
D: 首先预处理，合并相邻相同元素，记录{val, len}，叫这个数组为b。基本思想是greedily地对当前b[i]取较好地情况（需要证明）。当len=1的时候需要考虑分配不同边来保证不会重叠，例如[3, 3, 5, 4, 3, 3]。对于len>=2，是否需要分配到两边，还是让没有被分配到的那组保持前一个数较好？比如[3, 3, 5, 3, 3]，可以分配成[3, 3, 5, 3]和[3]或是[3, 5, 3]和[3, 3]，对于第一组[3, 3]假如不分配，那在下次见到3的时候也会将其覆盖到，所以是一样的，因此尽可能分配到两边。
当我们处理到b[i]的时候，鉴于预处理我们知道b[i-1]!=b[i]。b[i−1]是其中一种颜色的最后一个，所以我们想知道对于另一种颜色有哪些可以取。我们用一个叫alter的set来记录潜在的元素。对于D1我们希望取不同的元素，对于D2我们希望取相同的元素。
在alter中的元素可以被放到与b[i-1]相同或不同的颜色。我们可以重新排序来将任意在alter中的元素放到那个color的结尾。例如：b[i−1]=3，alter=[1,2,4]。我们可以通过reorder来将1变成其中一种颜色的结尾：[...,2,...,4,...,3] and [...,1]。
对于第一个问题：当b[i]的len≥2，那我们会将其分配到两组。当b[i]的len=1，我们需要考虑放到哪一种颜色。我们知道b[i−1]!=b[i]，所以我们想要检测在另一种color中有没有与b[i]不同的元素，所以我们check alter。如果有的话，那代表b[i]可以放到任意一组，对b[i-1]来说它可以与b[i]同色或是不同色，所以我们可以将b[i]放到alter。如果没有，那代表b[i-1]一定是b[i]的前一个元素，所以b[i-1]是fixed。
对于第二个问题，思路类似并且更加简单，我们只需要check b[i]是不是在alter中并且update alter