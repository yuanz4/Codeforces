https://codeforces.com/contest/1440
C1: 可以发现每个2x2都可以最多用4步转化为全0，1111->0001->0011->0111->0000。因为可以取到任意三个的组合，所以顺序不重要们，可以用multiset来存储状态，注意不能在遍历的时候更改，最好复制一个一样的对复制品遍历。在这里对每个2x2遍历就行，会有重叠的部分，因为之前的已经遍历过，所以有2个是0，因此之后的grid最多3次
C2: 将原图划分为不重叠的2x2，每个最多4次。要考虑的是行或列为奇数的情况，其实比较简单的想法是将bottom和right的border先全部转为0，然后再对左上的偶数矩阵分割。一开始没做出来是因为陷入了分类讨论的陷阱，讨论了所有边上2x3和角上3x3的情况，非常难实现。下次遇到实现过于麻烦的情况时应该想想有没有简单的方法，需要逆向思维
D: 可以对所有点根据degree进行从小到大排序，假如d<k-1，则可以将其与相邻边都删去，用不到了。假如d>=k，则说明剩下的点都满足至少有k个neighbors的要求了，则它们就是结果。当d=k-1时，可以作为clique的candidate，保存下来。当把所有点都遍历完后还没有满足k neighbors的subgraph，就考虑clique的candidate，对每个点检测其邻边看是否能构成clique。这里其实有些点的d>=k，但是有与他相连的clique candidate被remove了，因此我们在遍历 的时候得要按被放入candidate的顺序遍历。

E: 用segment tree来维护最大值、最小值和sum。2操作时，假如child节点的min比y小，说明会有贡献，因此要进入。假如child节点的sum比y小，说明整棵subtree都会被计入。这里y最好传入reference，所以可以将有贡献的节点减去。对于1操作，也是对某一个范围取max。这里update的时候可以使用lazy propagation来更新{min, max, sum}。1操作的时间复杂度可以看出来是logn。2操作的时间复杂度与访问了多少subsegments有关，这里可以证明他最多经历了log2(maxY)个不同的subsegments：在他开始一个连续subsegments之前有y，则当他买不了的时候剩下的钱最多为y/2，也就是说每次至少减半，因此每个2操作的时间复杂度是log2(maxY)logn