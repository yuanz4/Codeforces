https://codeforces.com/contest/1426
E: 也可以用max flow来做，将s与a连接，然后将a与平手和输的b相连，再将b与t相连，则minimum win是n-max_flow，这样可以直接套模板来计算，但是比较麻烦，有更加简单的方法。比如用a1 a2 a3 b1 b2 b3来表示，对于每一种a获胜的情形(a1, b2), (a2, b3), (a3, b1)我们都希望他们尽可能的少。首先放置(a1, b2)，尽可能错开，则相交的会有max(a1+b2-n, 0)个。再对第二个(a2, b3)处理的时候，假如a1+b2>n，那么对于a2来说对面都是b2，所以不会有与b3相对的情况。另外，不可能存在两组加起来>n的情况，因为a1+b2+a2+b3>2n不可能，所以最多只有一组会产生>n。接下来要证明假如都<n，则存在一种放置方法使结果为0。假如先考虑1，再考虑之后的，可能会出问题，如下：
a: 1 1 1 1 1 2 2 2 2 3
b: 3 3 3 3 3 1 1 1 2 2
我们想要证明，对该bipartite存在一种perfect matching，相连两个array中不同的数（比如a中的1和b中的3）。需要用到Hall's theorem，意思就是说对于任意一个a的subset s，在b中与其相连的点至少有|s|个。所以假如我们考虑a1中的subset，则|{b2,b3}|>=|s(a1)|。而假如s包含了多余一种数字，则n>=|s|
F: a,ab,abc记录的是到当前为止?取所有可能性时a,ab,abc的subsequence的个数。当出现?时，之前所有的a,ab,abc个数都会乘以3，因为无论?取什么，对之后的元素来说相当于有...a,...b,...c三种组合。同时假如取c，还要加上之前ab的个数；假如取b，要加上之前a的个数。对于m的解释，记录的是不同的string的数量：当没有问号时，只有一个fixed string；当多出一个问号，相当于可能性会乘以3。所以不同string的数量为k^3，k为问号的数量。对于...?的情况，当问号取a时，对之后的字母来说，相当于有k^3个以a结尾的string，所以a的数量要加上k^3