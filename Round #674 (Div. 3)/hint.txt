https://codeforces.com/contest/1426
E: 也可以用max flow来做，将s与a连接，然后将a与平手和输的b相连，再将b与t相连，则minimum win是n-max_flow，这样可以直接套模板来计算，但是比较麻烦，有更加简单的方法。比如用a1 a2 a3 b1 b2 b3来表示，对于每一种a获胜的情形(a1, b2), (a2, b3), (a3, b1)我们都希望他们尽可能的少。首先放置(a1, b2)，尽可能错开，则相交的会有max(a1+b2-n, 0)个。再对第二个(a2, b3)处理的时候，可以不用管第一个，因为对于a2来说，对面可能是空的或者是b2，但是都无所谓，所以可以视作是全空的情形，也可以用max(a1+b2-n, 0)来计算。假如a1+b2>n，则对于另外两种情形都不会大于n，因为a1+b2+a2+b3>2n不可能，所以我们可以得出最多只有一种情形会产生>n。假如都<n，那结果就是0
a1 a1 a1 a1 a1 a2 a2 a2 a3 a3 a3 a3 a3
b3 b3 b3 b1 b1 b1 b1 b2 b2 b2 b2 b2 b3
问题是如何证明？
F: a,ab,abc记录的是到当前为止?取所有可能性时a,ab,abc的subsequence的个数。当出现?时，之前所有的a,ab,abc个数都会乘以3，因为无论?取什么，对之后的元素来说相当于有...a,...b,...c三种组合。同时假如取c，还要加上之前ab的个数；假如取b，要加上之前a的个数。对于m的解释，记录的是不同的string的数量：当没有问号时，只有一个fixed string；当多出一个问号，相当于可能性会乘以3。所以不同string的数量为k^3，k为问号的数量。对于...?的情况，当问号取a时，对之后的字母来说，相当于有k^3个以a结尾的string，所以a的数量要加上k^3