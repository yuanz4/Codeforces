https://codeforces.com/contest/1465
B: 用unordered_set记录digits导致TLE，非常莫名其妙，按理来说应该只是一个非常小的constant
C: 有些点可以直接移到diagonal，或者需要两步，点之间会互相牵制。其实可以转化为图，初始化ans=m，假如已经在diagonal了就-1，假如出现环就+1，因为需要多一步，然后可以打破环，剩下的点都只需要一步。假设一个点为(x1, y1)，另一个点为(x2, y2)，令图代表x->y，我们默认将所有点纵向移，当y1=x2，代表要将x1竖着移到y1时那一行已经有另外一个点了。假如有一条path是abc，箭头代表会受到牵制，那么a->b->c代表都竖着移，a<-b<-c代表都横着移。a纵向移会遇到b，等效b横向移会遇到a。一系列互相牵制的点，只可能成环或者不成环，所以定义边时x->y或者x<-y都行。该图中的环都是独立的环，没有任何进边和出边。我的做法是检测当某个元素移动到对角线时是否有哪行哪列空出来了，写起来非常复杂
D: 本来想着用d[i][k]代表到第i个数，并且把其中k个?代替为0能得到的最小值，但是这样的话数组非常大，会超过memory limit，其实这里是因为miss了observation。其实可以证明假如01更好，那就把某prefix写为0并且之后写为1；假如10更好，就反过来。比如说01更好，那么假设存在某两个mark为aaaaa1.....0bbbb，首先对于a和b来说没有区别所以可以忽略，对于中间的数来说，aaaaa1..0..0bbbb或是aaaaa1..1..0bbbb都会出现10，那么这时候肯定是把两端换为01更好，这样对中间的0或1（把?也当成0或1考虑）都是更优的01。因此假如01更好，那就不可能出现10的pair，也就是说只可能是0为prefix，1为suffix的情况，但是具体在哪里不清楚，所以尝试所有的情况。对于x<y的情况，先将所有?设为1，然后从左边开始逐个变为0，先减去其它所有0(01, 10)和之前的?(01)，然后加上所有1(10, 01)和之后的?(01)
E: 可以发现最后一个数一定是+，倒数第二个数一定是-，然后我们可以找到一种划分方法来使别的位置是任意+/-。比如---+++-+-++-+，先把最左边的-去掉，一个一个split就行，变成+++-+-++-+，必然最左边是+，如果之后都是+就结束，否则找到第一个-，然后split，变成(---+)(+---++-+)，对于(---+)将左边的-一个个split，对于(+---++-+)继续recursive地做，会变成
(-+)(--++-+) => ++-+ => (--+)(+) => +
所以问题转化为，对于前n-2个数，选择符号使其加起来的和为某个数。可以将+-2^S[i]视作-2^S[i]+(0 or 2^{S[i]+1})，所以sum(+-2^S[i]) = T => sum(2^S[i+1] or 0) = T + sum(2^S[i])，先把每一位加到T上，然后相当于将一个数分解成带权的power of 2，比如某一位是k，意思是可以对那一位取[0, k]次。做法是，从最低位起，假如T为1并且权重>=1，那就将T和权重/2并且将剩余的权重加到更高的一位上，也就是说低位剩余的可以向高位转移并累加