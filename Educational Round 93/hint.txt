https://codeforces.com/contest/1398
C: convert p_r-p_l=r-l to p_r-r=p_l-l
D: d[i][j][k] means the greatest value with i, j, k as last selected elements，向后延伸的dp
E: 用两个set来存可以被double的和不被double的，在更新时很麻烦的一种情况是比如存在{1, 1}，则只有一个可以double；或是{0, 1, 1}，两个1都在要double的set里，但明显是不对的。这时候不用挪动1，而是只要更新res就行，即减去较小的1的值，并且加上不用double里面那个最大的值。因为这样才能保证下一次query能继续用当前的两个set，如果因为1的原因更改set的话下次就很难复原，很难想到可以这样解决。editorial里面的方法思路非常清晰
F: 用greedy的方法考虑，假设当前在pos，则我们需要知道下一个位置next，满足在[pos, next]中存在长度为x的符合序列，比如x=3，则1?00是一个符合的区间。因此对于x，每次跳跃的位置>=x，所以最后的时间是n/1+n/2+...+n/n = n*Hn (Harmonic number)，又因为ln(n+1)<=Hn<=ln(n)+1，所以时间复杂度是nlogn。很特殊，第一次见到这样logn的表达方式！实际实现中，对0和1分别记录从当前位置开始的最长的连续序列，需要开两个数组的原因是有?的存在，会对0和1产生不同的效果。假如len<x，则需要寻找下一个最近的位置，比如对于11??00，则我们希望从?开始，因为?是0的开头。但是这个优化还不够，假如遇到x=5，101011类似的情况，其实我们可以直接跳到第0+5=5个数字，然后找和它一样字符的开头，即这里的11。因为可以证明，下一段可能长度为x的连续字符的开头一定在[0, x]区间内，所以更快的方法是从x开始从后往前找