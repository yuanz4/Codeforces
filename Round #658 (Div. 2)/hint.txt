https://codeforces.com/contest/1382
D: 重要的观测是发现在最大数后面的元素一定属于同一个array。因为只需要一种解，只需回答对或不对，所以可以deterministic地构造。假如用dfs遍历会超时。在转化为subset-sum问题后，可以直接用dp来解，但也可以注意到所有长度和为2*n，所以将长度一样的block归到一起，总共有sqrt(n)种block，因为1+2+3+...+sqrt(n)能够组成n。因此相当于bounded-knapsack问题，每种长度有一个或多个，要挑出一部分组成长度为n。这个可以用单调队列来优化dp，变成O(MN)，M为总和，N为种类个数。在这题里可以变成O(nlogn)
D_better_space: 只用一维数组来记录状态，要注意的是得要倒序遍历，不然会访问到当前iteration下已经被改变的状态。需要牢记的是在0/1-knapsack中需要倒序遍历，而在unbounded-knapsack中需要正序遍历（相同元素可以取多次）
E: 一开始的想法是将frequency大的数字逐个相消（即对换位置），例如11234->112(4-3=1)->1112->11(2-1=1)->111->1(1-1=0)->1。但是这样的问题是交换位置都是成对出现的，当出现奇数个时会有问题。解答中比较难想到的是可以通过rotate一半长度来找到新的位置