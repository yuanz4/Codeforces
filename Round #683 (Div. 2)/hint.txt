https://codeforces.com/contest/1447
A: 每次操作等效于将某个元素减去i
C: 其实不用sort也行，因为去除比W/2大的元素后，剩下的元素相加不可能超过W。这里要注意的是ceil(W/2)，可以用cur>=(W+1)/2或是2*cur>=W代替，不能单纯地用W/2
D: d[i][j]代表的是a中以i结尾和b中以j结尾的最高score
E: 不会存在cycle，因为xor最小pair的两个元素一定会选择彼此相连(这个最小的xor对双方来说都是最小的)。当两个数最高位不同时是一定不会相连的，因此一定要把其中一个减小到1。一开始想错的地方是觉得最高位相同时内部一定是connected，但其实不对，比如[100, 101, 110, 111]，最高位相同时会处理下一位，假如下一位可以分成不同的group那么不会相连，因此应该recursively地处理。从最高位开始，假如能分割成两部分那就将小的那个变成1。也可以用Trie来储存所有的数字，这样在每一个bit时候可以轻松分开