https://codeforces.com/contest/1384
A: 更简单的方法是，将前一个string复制，然后在对应位置将char翻转成不同的
B2: 将可以的位置visualize一下之后可以发现规律，要注意的是，当一个位置是safe的时候，应当从潮水刚开始下降时开始遍历。并且应当从i=1开始而不是i=0，因为可能k > l导致i=0的情况出错
C: 也可以用graph做，可以得知每个weakly connected component（当把有向边改为无向边时的连通图）的操作是|C|-1，因此可以用dfs找subgraph的数量
D: 需要意识到，当最左位的1的个数为odd时，不管双方怎么取，最后两者的数都是一样的（都是0或者都是1）。然后得要意识到不仅要考虑ones mod 4，也要考虑0的个数，比如当1110的情况时候还是win（第一个人可以先取0）