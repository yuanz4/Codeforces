https://codeforces.com/group/tKC7z9Nm0A/contest/320020
B: 要使最短边取最大值，然后使任意两点路径上的最短边之和最小。在对最短边取最大值时，一开始想的做法是将边的weight排序，然后从小开始删边，使得每个点至少还有一条边，但是这样是不对的，因为不能保证连成MST，比如两个点相连但是不与别的点相连。所以应该从大到小寻找能组成MST的最大i，然后在[i..m]中构建MST，因为每条边的weight都是不同的，所以不会有两条边一样的情况。最后在计算树上任意两点最小边和的时候，对于每一条边，计算左右各有多少点通过它，然后相乘。从最大weight开始往左右加点，这样左右subtree的边都是大于当前weight的，即左右的rank就是实际的点数。当出现a-8-b-4-c-6-d时，对于6而言左右各1，因为4将其隔断了。这个常见的思想是，当计算所有pair的sum时，对每一条边计算contribution。在这里，MST与任意两点路径上的最短边的最小和，这两个问题是不等价的，可以举出反例：
  1  2
a--b--c
  3|  |6
   d--e
     5
在这里已经满足了policy2，对于MST会删去ce，但是最短和的时候是要删去de
C: 要注意这里是monitor edge，而不是vertex。所以当0点为0时，n-1一定是1；当0点为1时，n-1可以是0或者1。当处理环时，常见的做法是从某点断开然后做两次dp。假如是monitor vertex的话，那要keep track前两个元素，dp的状态是d[i][mask]，mask代表的是00,01,10,11，即第i个和前一个是否装配。因此切开后，对于initial state，要尝试两个node的所有状态，并且对于最后一个state，要定义需要的状态是什么。假如最前面的状态是1，那最后的可以取d[n-1][00,01,10,11]，然后取最小
D: 对于每个点，计算前k-1次经过了多少次。要注意不能在main里面开太大的array，当超过大约2e6的时候就会segment fault，stack的大小有限制，要定义在global里。时间卡的有点紧