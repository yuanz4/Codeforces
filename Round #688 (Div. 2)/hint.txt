https://codeforces.com/contest/1453
B: 假如一个数都不能改，那么就是所有相邻数之差的和sum。改变的那个数，假如在头或是在尾，则是减去那一个gap；假如在中间，一定会移到前后元素的中间，然后|x-y|+|y-z|会变成|x-z|，而且可知|x-y|+|y-z|>=|x-z|，因此每次更改后sum一定不会增大。对每个数字计算更改后会减小的值，然后用sum减去
C: 对于任意两个点，可以选择计算x上的diff并将任意一个点沿着y扩展，或是计算y上的dff并将任意一个点沿着x扩展。如果对每两个数字进行比较会超时。因此想到假如一个点是v，那么它会想找在x或者y上与它最远的点u，然后v在另一个方向上扩展。有两种特殊情况，一种是那个最远的点就是它自己，那么相减是0可以不用考虑。另一种情况是会不会是从u扩展，而不是从v扩展，对于这种情况，其实包含在对u的考虑中，u也会去找离它最远的点，一开始这里没想清楚
D: 如果前一个点是checkpoint，E[1]=1/2+1/2*(1+E[1])->E[1]=2。对于1000的情况，E[i]=1/2+1/2*(1+E[i-1]+E[i])->E[i]=2+2*E[i-1]->E[i]=2^(i+1)-2。可以greedy地从k里面取出最大满足的sequence，因为2*E[i]<E[i+1]，所以这样肯定可以取较小的个数。sequence的长度最大不超过60，这时候已经满足10^18的限制了，远小于2000
E: 在每个分岔点，先走最深的子树，然后从最浅的子树往回走，这样可以保证k最小。计算从一个子树走到另一个子树需要depth+1，但是要注意这只有在有多个子树的时候才需要计算。另外，当分岔点是起始点时，先走浅的，只要用倒数第二个+1来更新k
F: 首先会想到用一维的d[i]来记录到达i点只有一种路径时最少需要的操作，但是这样的信息是不完全的，因为predecessor可能到达并越过了i，这样我们在计算之后d的时候不知道到底越过了多少。所以可以用d[i][jump]来记录到达i只有一种情况并且以jump结尾的情况。那么对于每一个i，我们想要去找其predecessor，这个j可能是从i-1到1，假如j+aj>=i，那么说明再跳一步就到i了，我们可以更新d[i][j+aj]。我们只关心d[j][k]，其中j<=k<=i-1，因为假如k>=i，那么它已经覆盖i了，也就不用再跳了，此处该predecessor也会在对j的遍历中被覆盖到。对j要从i-1遍历到1，假如j可以，而j-1也可以，那么j-1可以跳到j，所以也就能跳到i，那有两条路了，因此要将j设为0，相当于cnt用来记录当前j到i之间满足的个数，都要置为0。按照这样写出来是O(n^3)。我们可以发现在取k的时候，我们想要找d[j][k]最小的一个，那其实就可以改变dp的定义，改为最远到达jump时的最小值，这样我们可以直接从d[j][i-1]取到，并且我们只要对d[i][jump]取prefix min来更新就行。填充dp的顺序是，外圈是i，然后内圈为d[i][i...n]。这其实也是一种dp的optimization，将三维转为二维，最终为O(n^2)