https://codeforces.com/contest/1466
C: 假如有回文串abcba，那么只需要将靠中间的一个字符替换即可，比如变成abcda。因此目标是找出回文串的中心点并替换，不用在意替换成什么字符，因为总可以找到合适的字符，并保证不会与后面的substring组成回文。当考虑bbbbbbb时会发现，要替换第2、3位，然后5、6位。所以其实保证每三个连续字符串不构成回文即可，如果遇到回文，将靠后的字符替换掉，因为这样有概率能消除未来的palindrome
D: 每增加一个subgraph可以将一个点多用一次，因为是树所以每次只会从一个点断开，当一个点有>1条边时可以断开。所以每次当k增加时，我们找weight最大的能断开的点
E: 先固定xi和xj，这样相当于要取所有k的xj|xk。对每位来考虑，当xj的那一位为1，则那一位可以得到n*2^b，否则是bit[b]*2^b，bit[b]为n个数在那一位的sum。同理固定xj和xk，只有当xi那一位为1时会加上bit[b]*2^b，为0时不加。因此对每个xj，我们需要求a1*b1+a1*b2+...+a1*bn+...+an*bn=(a1+...+an)*(b1+...+bn)，按上述方法处理，最后时间复杂度为O(60*n)
F: 可以发现|T|是2的次方，可以理解为要找前|S'|个独立的vectors，也就是vector basis，这样选取他们其中的一个subset总共可以构成2^|S'|个结果。所以问题是如何选取basis，假如我们已经确定了在i之前的basis，那么我们要检验第i个能否由之前的basis转换而来。k有1和2两种可能性，对于k=1时一定是basis。假如一个basis只有第j位是1，那么假如有另外一个vector第j和k位是1，那么就能将其简化为只有第k位是1，类似gaussian elimination。因为顺序不好定，所以会想着建图，当k=2时，代表一条连接u和v的边。对于一条path而言，上面的任意两点（某个vector其中那两点的位置是1）都已经被囊括了，也就是说对于一个新的vector，如果u和v已经是connected，那么这个vector已经被包括了，不是basis。所以相当于找出connected subgraph中边的数量，每条边是一个vector basis，也就是找出minimum spanning tree。对于k=1的点非常特殊，他代表一个点，并且与其相连的任意点都可以作为basis，这时候是点的数量。假如在全是k=2的图中，将其中一个点设置为特殊点，那么会从计算边upgrade为计算点，也就是+1，并且再加入k=2的新边，该图也仍然是计算点。但是假如这个图中已经有特殊点，那么这个新点就是多余的。假如新边的u和v都是计算点的，那我们只需要将u和v连起来，但是不需要加入新的basis。因此我们将该subgraph是计算点还是边存在subgraph root里，然后以此类推来加入新的vector (k=1 or 2)。editorial中用了一种比较tricky的方法，将k=1的情况在最后多加一维并且设为1，这样就全部都是k=2的情况，所以找出mst中所有边的数量即可