https://codingcompetitions.withgoogle.com/codejam/round/00000000004362d7
A: 要注意可能两个数字都在同一个interval的情况，*1.0会转换为double
B: 先将y划分出第一个数的长度，从1到n/2，然后按照这样往后找比前一个大1的数，假如后面出现不够了就+1。但是会有进位的问题，所以可能会有意外情况出现，比如9979999，答案是999'1000，这里需要将997+2。在尝试997的时候发现998<999，所以前面的数还不够大，需要继续+1。而找到998'999'9时，然后发现最后只剩一个9了数字不够，也仍然需要+1。所以发现数字不够后还得继续往上+1来找到能将y完全划分的方案，要找到最小的那个值。在这里如果用binary search，难点在如何判断向左还是向右找。经过一番思考，这样做是做不出来的，无法判断。
正确的做法应该首先选择要将其划分为几段，比如说是2段。设第一段从x开始，则f(x, 2)=concatenate(x, x+1)是一个increasing function，可以用binary search。我们根据x和d来求f(x)。然后我们要找到最小的比input大的结果。当input是1e18时，最大的结果是1234567891011121314，因此可以将inf存为2e18
C: 