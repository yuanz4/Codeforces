https://codeforces.com/contest/1436
E: 因为1<=a<=n，所以每个subarray的MEX只可能是[1...n+1]，而最终的MEX只可能是[1...n+2]。因此我们从小到大，检验每个值是否是subarray的MEX。可以知道假如在一个subarray中存在y，则这个subarray的MEX不会是y，因此要使y成为某一个subarray的MEX，这个subarray一定在y之间。所以对于一个值y，将其作为隔板进行划分...y...y...y..，然后我们检验每个区间[l...r]的MEX是不是y，等效于想要知道它的MEX是多少。这个MEX肯定不会比y大，也就是在[1...y]的范围内。假如所有区间的MEX都没有y，那么y就可能是最终的MEX。所以我们要快速找出在[l...r]中第一个不存在的数x，假如现在的数组只有[1...r]，那么x最后一次出现last(x)一定<l。因此用segment tree查询，叶节点存每个positive integer（从1到n，从左到右）最后出现的坐标i，然后每个node存的是这一个区间里最小的i。把a中的值一个个加进segment tree，假设处理到a[j]（a[j]还没加进去），然后在[last(a[j])+1...j]这段区间内（简写为[l...r]），我们想要找到第一个不存在这个区间内的positive integer，也就是在segment tree中的leftmost leaf whose value < l。假设这个数是x，那说明[1...x-1]最后出现都在[l...r]的范围内，而x不在这个范围内，所以这个x就是MEX。对所有元素插入之后，要注意检查最右边的区间，以及整个区间。其实这个[l...r]的query对任意一个区间做都是可以的，在segment tree中检查输入的l到最后插入元素的r，但如果都做就会是O(n^2)，在这里我们只关心对y的检测。这是一种offline算法，因为我们对a一个个插入，边插入边计算结果