https://codeforces.com/contest/1443
B: 其实不用将中间的0排序，类似一个dp。因为对于一个新的0 segment，只要其是以1开头，那么在此之前的状态与其无关，不用记录，只关心之前的最值是多少
D: 将左边下降的去掉之后，相当于在中间的元素中，需要把每个元素减去一个值cut使得相减后的值是non-decresaing的，cut得是non-increasing，可以greedy地减使cut尽量大
E: 类似nth permutation sequence，但是这里的n和k很大，因此在从后往前计算阶乘的时候只需要计算到<=k为止。这里的一个optimization是，只需要更新从start开始的interval就行，因为之前的元素和prefix sum都是不会变的，这样每次改的只是后面的一部分，最多为最后15个元素，10^10，而不是整个长度为n的array。在更新时，用vector或者set都行，都要找到第j大的元素，都是O(n)
F: 只需要检测相邻的元素是否会在之后出现，不能删去之后要插到b里的元素。不同的操作顺序不会产生相同的t，所以不用关心。也不用考虑移位带来的后果，比如a = 3 2 5，b = 3 5，对于5来说新的相邻是3，但是3可以删去，因为新的相邻只可能是之前已经插到b里的元素，不可能会把b之后的元素插进来