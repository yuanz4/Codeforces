https://codeforces.com/contest/1457
C: d[i]代表的是如果能达到这个位置，则弹到最后需要的时间
D: 将有相同最大1的定为同一个level，当一个level中有>=三个数时，合并较大的两个就可以完成。所以剩下的必定每个level包含一个或两个数，这时候要想着从大到小合并两个同level的，他们会往下降level。假如合并后的数比下一个小，那就结束，不用继续往下；或是比下一个level大，那就舍弃掉；剩下的情况只可能是和下一个level一样大。那么假如该level有三个数，可以记一下结果，并且停止之前的过程，因为到这里已经到头了，往下传递一定会要更多step。但是要注意的是仍然要将原有的两个数合并再往下传递，例如[1, 2, 2, 4, 6]的情况，两个2仍然要和1比较。要注意每次在比较时有两种可能，比如[x, y, z]其中x和y在同一level，z在下一level，那么有[x^y, z]和[x, y^z]两种情况需要考虑，但是在传递的时候仍然只传递x^y，因为假如传递两个不同level的，那这个结果肯定比所有lower level的数要大
D_brute_force: 其实当每个level不存在三个数时，n最大只可能是64左右，int共32位类似抽屉原理，所以可以brute force地尝试所有的情况。尝试xor每一个[l,k]>[k+1,r]，这样最终为64^3，不过通过前一种做法可以证明[l,k]的长度最大为2。下次在做与bit有关的时候应该考虑到其受到int的限制，所以时间复杂度可能不是与n有关
E: 将所有数字分成k+1个stack，然后将最后的和写成系数的形式(x-1)a1+(x-2)a2+...+(0)ax，然后可以发现要把负数的那些平摊，同一个level上的顺序不重要，前缀和是正数的那些堆积在同一个平台上
E_pq: 用priority queue可以写得很方便，但是需要证明其正确性。首先当prefix sum是正数时，都会stack在一起，然后出现的第一个prefix sum负数ai，相当于ai+prefix_sum，prefix_sum>=0，所以ai+prefix_sum必定仍然是剩余负数中最大的。因此考虑所有数都为负数的情况，要证明每两个高度差不会超过1。或者可以转化为，一系列non-decreasing height的box，放到k个bucket中，每次挑选最小height的堆叠，任意两个bucket的木块数量差不会超过1。假设两堆木块数量一样，高度分别为ai, aj，我们需要避免ai+ci<=aj的出现。如果可以证明数量为n+1的总比数量为n的高，那每次都取数量为n的，可以满足之前的证明。需要用数学归纳法，base case是只有一层时可以满足，因为在每个0上放，所以一定成立。之后的归纳部分是：假如现在有数量为m和m+1的两种stack，而我们会取一个数量为m的最小高度ai的stack，我们需要证明对于任意有同样数量的aj，ai加上当前c[i]后后会比aj大。我们可以将ai最上面一个高度为bi的box取出来，也将aj最上面一个高度为bj的box取出来，则根据之前的推论，ai>(aj-bj)。又因为ci在bj之后，所以ci>=bj，所以ai+ci>(aj-bj)+bj，因此满足